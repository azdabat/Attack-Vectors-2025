# Case Study: Behavioural Detection of Polymorphic Loaders & Supply-Chain Sideloading  
### Using Ala Dabat’s Multi-Stage Sideloading & Driver Abuse Detection Rule

This section documents an example of **production-grade behavioural detection** designed to catch the early stages of polymorphic malware and supply-chain compromise.  
The rule below is authored by **Ala Dabat**, and is a strong representation of modern detection engineering principles in 2025.

---

## 1. Why This Rule Matters in a Polymorphic Context

Polymorphic malware rarely exposes:
- stable hashes  
- reusable file content  
- repeatable filenames  
- predictable infrastructure  

Therefore, **hash-based TI is almost worthless**, especially during:
- 0-day supply-chain events (SolarWinds, 3CX)  
- polymorphic loaders (Latrodectus, Pikabot, Rhadamanthys)  
- BYOVD exploitation  
- staged/sleeping DLL deployments  

This rule avoids all static artefacts and instead models the **actual tradecraft sequence** of a modern intrusion:

1. **A component is dropped where it shouldn’t be**  
2. **It is unsigned or badly signed**  
3. **It is loaded by a high-value process**  
4. **Or loaded very quickly after drop (0–5 min offset)**  
5. **Or loaded by a LOLBIN**  
6. **Or dropped but left dormant (SolarWinds-style)**  
7. **Or downloaded remotely during execution window**  
8. **Or registered in persistence keys**  

This is the **behavioural signature of polymorphic access brokers** in 2023–2025.

---

## 2. Polymorphic Kill-Chain Alignment

The rule provides coverage of the following polymorphic stages:

| Kill Chain Stage | Behaviour Detected | Covered By Rule | Strength |
|------------------|-------------------|------------------|----------|
| Initial foothold | Temp/AppData staged DLL/EXE | ✔ | Medium |
| Loader deployment | Fast DLL load (<5 min) | ✔ | Strong |
| Memory prep | Unsigned/Unknown DLL/SYS loads | ✔ | Strong |
| Dormancy | Dormant DLL/SYS >7 days | ✔ | Very Strong |
| BYOVD | Dropped SYS driver without load | ✔ | Strong |
| C2 staging | Remote download of DLL/EXE | ✔ | Medium |
| Persistence | Registry keys referencing binaries | ✔ | Strong |
| Sideloading | High-value process loads unsigned DLL | ✔ | Very Strong |

This is more **kill-chain coverage** than most vendor-provided rules.

---

## 3. Why This Works Against Polymorphic Malware

Polymorphic malware:
- Randomises payload structure  
- Changes offsets, stubs, and block order  
- Encrypts payloads  
- Compiles per-host  
- Evades sandboxes by delaying execution  
- Uses LOLBINs to mask loader behaviour  

**The one thing they cannot hide is behaviour.**  
Your rule focuses entirely on **behavioural invariants**.

Examples:

### ✔ Polymorphic Loader Example (Latrodectus)
Latrodectus relies on:
- unpacked DLL dropped into AppData  
- loaded fast by a LOLBIN  
- unsigned module load  
Your `SuspiciousDLLFast` flag catches this.

### ✔ SolarWinds/SUNBURST-Style Dormancy
The SUNBURST backdoor:
- was dropped but unused for weeks  
- remained unsigned after tampering  
Your `DormantDLL` and `DormantDriver` flags catch this.

### ✔ NotPetya-Style Driver Abuse
NotPetya staged modified drivers silently in:
- ProgramData  
- Temp directories  
Your writable-path + bad signature detection catches this.

### ✔ 3CX Telemetry Indicators
3CX used:
- DLL sideloading  
- unsigned Or invalid signature chains  
- high-value parent process  
Your `FastDLL_ParentHighValue` captures that logic.

---

## 4. Where MDE, Sentinel, and CrowdStrike Strengthen This Detection

### **Microsoft Defender for Endpoint (MDE)**
MDE provides:
- Detailed `DeviceImageLoadEvents` (signature state)  
- `DeviceProcessEvents` for loader ancestry  
- Network and registry telemetry  
- Memory injection (used as follow-on hunts)  

Your rule correctly uses MDE’s **strongest and most stable tables**.

### **Microsoft Sentinel**
Sentinel allows:
- Sysmon augmentation  
- Firewall logs  
- Cloud logs (AzureActivity)  
- Enrichment with identity anomalies  

This rule becomes **much more powerful** when correlated to:
- impossible travel  
- OAuth consent  
- token replay  
- unusual cloud pivot  

### **CrowdStrike Falcon**
Falcon complements your detection by catching:
- ThreadInjection  
- ProcessManipulation  
- UntrustedLoad events  
- Cross-process injection  

**Your rule detects the delivery and sideload stage; Falcon detects the in-memory stage.**  
Together they produce a full kill-chain view.

---

## 5. Analyst Workflow: What To Do When This Rule Fires

A real-world triage approach:

### Step 1 — Validate the file drop
Check if the DLL/driver belongs to:
- a legitimate software update  
- a known vendor  
- a legitimate installation flow  

If *no* → escalate immediately.

### Step 2 — Analyse the loader process
If parent is:
- rundll32  
- powershell  
- regsvr32  
- mshta  
It indicates staging or loader activation.

### Step 3 — Look for memory injection
Pivot into:
```
DeviceEvents
| where ActionType in ("CreateRemoteThread","MemoryWrite","MemoryAllocate")
```
This is the **next phase in polymorphic operation**.

### Step 4 — Look for identity drift
Query:  
```
SigninLogs
| where UserPrincipalName == "<affected user>"
| where Timestamp between (DropTime .. DropTime+1h)
```

### Step 5 — Look for cloud metadata access
Polymorphic loaders often pivot to cloud via:
```
RemoteIP == "169.254.169.254"
```

### Step 6 — Check for lateral movement precursors
Query:
```
DeviceNetworkEvents
| where InitiatingProcessFileName in ("psexec.exe","wmic.exe","sc.exe","powershell.exe")
```

### Step 7 — Check other hosts
Staged supply-chain attacks never impact one host.  
Run your rule **tenant-wide** to identify scale.

---

## 6. Final Notes for Senior Analysts

This rule is one of the strongest behavioural supply-chain/sideloading detectors you can deploy in 2025 because:

- It is **not signature-based**  
- It models **how** attackers operate, not *what* they drop  
- It works against **0-day** and **N-day** supply-chain compromises  
- It surfaces **pre-execution** activity (dormant DLL/driver stages)  
- It correlates **across multiple telemetry domains**  
- It is compatible with **MDE**, **Sentinel**, and **CrowdStrike**  
- It fills the detection gap between **delivery** and **memory execution**  

This makes it a model example for future behavioural detections in your repo.
