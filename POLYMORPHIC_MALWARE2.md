# Case Study: Behavioural Detection of Polymorphic Loaders & Supply-Chain Sideloading  
### Using Ala Dabat’s Multi-Stage Sideloading & Driver Abuse Detection Rule

This section documents an example of a rule still in design phase designed to catch the early stages of polymorphic malware and supply-chain compromise.  
The rule below is authored by **Ala Dabat**, and is a strong representation of modern detection engineering principles in 2025 (see end of document for rules).

---

## 1. Why This Rule Matters in a Polymorphic Context

Polymorphic malware rarely exposes:
- stable hashes  
- reusable file content  
- repeatable filenames  
- predictable infrastructure  

Therefore, **hash-based TI is almost worthless**, especially during:
- 0-day supply-chain events (SolarWinds, 3CX)  
- polymorphic loaders (Latrodectus, Pikabot, Rhadamanthys)  
- BYOVD exploitation  
- staged/sleeping DLL deployments  

This rule avoids all static artefacts and instead models the **actual tradecraft sequence** of a modern intrusion:

1. **A component is dropped where it shouldn’t be**  
2. **It is unsigned or badly signed**  
3. **It is loaded by a high-value process**  
4. **Or loaded very quickly after drop (0–5 min offset)**  
5. **Or loaded by a LOLBIN**  
6. **Or dropped but left dormant (SolarWinds-style)**  
7. **Or downloaded remotely during execution window**  
8. **Or registered in persistence keys**  

This is the **behavioural signature of polymorphic access brokers** in 2023–2025.

---

## 2. Polymorphic Kill-Chain Alignment

The rule provides coverage of the following polymorphic stages:

| Kill Chain Stage | Behaviour Detected | Covered By Rule | Strength |
|------------------|-------------------|------------------|----------|
| Initial foothold | Temp/AppData staged DLL/EXE | ✔ | Medium |
| Loader deployment | Fast DLL load (<5 min) | ✔ | Strong |
| Memory prep | Unsigned/Unknown DLL/SYS loads | ✔ | Strong |
| Dormancy | Dormant DLL/SYS >7 days | ✔ | Very Strong |
| BYOVD | Dropped SYS driver without load | ✔ | Strong |
| C2 staging | Remote download of DLL/EXE | ✔ | Medium |
| Persistence | Registry keys referencing binaries | ✔ | Strong |
| Sideloading | High-value process loads unsigned DLL | ✔ | Very Strong |

This is more **kill-chain coverage** than most vendor-provided rules.

---

## 3. Why This Works Against Polymorphic Malware

Polymorphic malware:
- Randomises payload structure  
- Changes offsets, stubs, and block order  
- Encrypts payloads  
- Compiles per-host  
- Evades sandboxes by delaying execution  
- Uses LOLBINs to mask loader behaviour  

**The one thing they cannot hide is behaviour.**  
Your rule focuses entirely on **behavioural invariants**.

Examples:

### ✔ Polymorphic Loader Example (Latrodectus)
Latrodectus relies on:
- unpacked DLL dropped into AppData  
- loaded fast by a LOLBIN  
- unsigned module load  
Your `SuspiciousDLLFast` flag catches this.

### ✔ SolarWinds/SUNBURST-Style Dormancy
The SUNBURST backdoor:
- was dropped but unused for weeks  
- remained unsigned after tampering  
Your `DormantDLL` and `DormantDriver` flags catch this.

### ✔ NotPetya-Style Driver Abuse
NotPetya staged modified drivers silently in:
- ProgramData  
- Temp directories  
Your writable-path + bad signature detection catches this.

### ✔ 3CX Telemetry Indicators
3CX used:
- DLL sideloading  
- unsigned Or invalid signature chains  
- high-value parent process  
Your `FastDLL_ParentHighValue` captures that logic.

---

## 4. Where MDE, Sentinel, and CrowdStrike Strengthen This Detection

### **Microsoft Defender for Endpoint (MDE)**
MDE provides:
- Detailed `DeviceImageLoadEvents` (signature state)  
- `DeviceProcessEvents` for loader ancestry  
- Network and registry telemetry  
- Memory injection (used as follow-on hunts)  

Your rule correctly uses MDE’s **strongest and most stable tables**.

### **Microsoft Sentinel**
Sentinel allows:
- Sysmon augmentation  
- Firewall logs  
- Cloud logs (AzureActivity)  
- Enrichment with identity anomalies  

This rule becomes **much more powerful** when correlated to:
- impossible travel  
- OAuth consent  
- token replay  
- unusual cloud pivot  

### **CrowdStrike Falcon**
Falcon complements your detection by catching:
- ThreadInjection  
- ProcessManipulation  
- UntrustedLoad events  
- Cross-process injection  

**Your rule detects the delivery and sideload stage; Falcon detects the in-memory stage.**  
Together they produce a full kill-chain view.

---

## 5. Analyst Workflow: What To Do When This Rule Fires

A real-world triage approach:

### Step 1 — Validate the file drop
Check if the DLL/driver belongs to:
- a legitimate software update  
- a known vendor  
- a legitimate installation flow  

If *no* → escalate immediately.

### Step 2 — Analyse the loader process
If parent is:
- rundll32  
- powershell  
- regsvr32  
- mshta  
It indicates staging or loader activation.

### Step 3 — Look for memory injection
Pivot into:
```
DeviceEvents
| where ActionType in ("CreateRemoteThread","MemoryWrite","MemoryAllocate")
```
This is the **next phase in polymorphic operation**.

### Step 4 — Look for identity drift
Query:  
```
SigninLogs
| where UserPrincipalName == "<affected user>"
| where Timestamp between (DropTime .. DropTime+1h)
```

### Step 5 — Look for cloud metadata access
Polymorphic loaders often pivot to cloud via:
```
RemoteIP == "169.254.169.254"
```

### Step 6 — Check for lateral movement precursors
Query:
```
DeviceNetworkEvents
| where InitiatingProcessFileName in ("psexec.exe","wmic.exe","sc.exe","powershell.exe")
```

### Step 7 — Check other hosts
Staged supply-chain attacks never impact one host.  
Run your rule **tenant-wide** to identify scale.

---

## 6. Final Notes for Senior Analysts

This rule is one of the strongest behavioural supply-chain/sideloading detectors you can deploy in 2025 because:

- It is **not signature-based**  
- It models **how** attackers operate, not *what* they drop  
- It works against **0-day** and **N-day** supply-chain compromises  
- It surfaces **pre-execution** activity (dormant DLL/driver stages)  
- It correlates **across multiple telemetry domains**  
- It is compatible with **MDE**, **Sentinel**, and **CrowdStrike**  
- It fills the detection gap between **delivery** and **memory execution**

- ## 7. ## Example: Using the Sideloading/Driver-Abuse Rule to Identify Component-Based Polymorphism

Ala Dabat’s rule is included here as a reference hunt to identify early-stage polymorphic loader behaviour.  
This includes:

- DLL dropped → DLL loaded <5 minutes  
- Unsigned DLL loaded by a high-trust process  
- Writable-path driver staging  
- Dormant driver chains similar to F5/NotPetya  
- Sideloading of unsigned libraries by office/communication apps

Use this hunt when correlating:
- staging behaviour  
- premature loading  
- suspicious parent-child relationships  
- prep for in-memory execution  

           POLYMORPHIC SUPPLY-CHAIN / SIDELOADING CHAIN
───────────────────────────────────────────────────────────────
[1] Dropper Staged in Writable Path
        ↓
[2] Unsigned DLL/SYS Dropped
        ↓
[3] Fast Load <5 Minutes (3CX Pattern)
        ↓
[4] High-Value Process Loads Unsigned DLL
        ↓
[5] Memory Injection / Unmapping / Hollowing
        ↓
[6] Token Theft / Cloud Pivot
        ↓
[7] C2 Establishment
        ↓
[8] Lateral Movement / Credential Abuse

## Mapping of Ala Dabat’s Sideloading & Driver Abuse Rule to MITRE ATT&CK

| Technique | Description | Rule Behaviour Trigger |
|-----------|-------------|------------------------|
| T1574.001 | DLL Sideloading | Fast DLL load / unsigned DLL in writable path |
| T1543.003 | Create or Modify Windows Service / Driver | Dormant driver, SYS dropped outside driver dirs |
| T1547.001 | Registry Run Key Persistence | RegistryValueData contains executable loader |
| T1105 | Ingress Tool Transfer | Remote download of DLL/SYS/EXE components |
| T1195 | Supply Chain Compromise | Manipulation of trusted vendor binary load path |

~~~
// =============================================================
// Supply-Chain & Sideloading / Driver Abuse Detection (TI-Free)
// Behaviour-First Rule — Unknown Vendor Compromise Ready
// Targets: 3CX, F5 BIG-IP, SolarWinds SUNBURST, NotPetya-style & Polymorphic Malware
// Author: Ala Dabat 
// Environment: Microsoft Defender for Endpoint Advanced Hunting
// Tables: DeviceFileEvents, DeviceImageLoadEvents,
//         DeviceRegistryEvents, DeviceNetworkEvents
// =============================================================

let lookback = 14d;

// Suspicious or user-writable directories
let suspicious_folders = dynamic([
  @"C:\ProgramData\",
  @"C:\Users\",
  @"C:\Temp\",
  @"C:\Windows\Tasks\",
  @"C:\Windows\Temp\"
]);

let high_value_processes = dynamic([
  "3CXDesktopApp.exe",
  "SolarWinds.BusinessLayerHost.exe",
  "outlook.exe",
  "teams.exe",
  "explorer.exe",
  "svchost.exe",
  "services.exe",
  "winlogon.exe",
  "lsass.exe"
]);

let lolbin_loaders = dynamic([
  "rundll32.exe","regsvr32.exe","mshta.exe",
  "powershell.exe","wscript.exe","cscript.exe","cmd.exe"
]);

let registry_keywords = dynamic([
  ".dll",".exe",".ps1",".bat",".vbs",".cmd",".js",
  "rundll32.exe","mshta.exe","powershell.exe","cmd.exe"
]);

let dormant_window = 7d;
let confidence_threshold = 3;

// 1. File drops in suspicious locations
let file_drops =
  DeviceFileEvents
  | where Timestamp >= ago(lookback)
  | where FolderPath has_any (suspicious_folders)
  | extend FileExt = tolower(tostring(split(FileName,".",-1)[-1]))
  | where FileExt in ("dll","sys","exe")
  | extend IsDriver = FileExt == "sys", IsDLL = FileExt == "dll"
  | project DropTime=Timestamp,DeviceId,DeviceName,FileName,FileExt,SHA256,
            FolderPath,InitiatingProcessFileName,InitiatingProcessCommandLine;

// 2. Unsigned / bad DLL or driver loads
let image_loads =
  DeviceImageLoadEvents
  | where Timestamp >= ago(lookback)
  | extend FileExt = tolower(tostring(split(ImageFileName,".",-1)[-1]))
  | where FileExt in ("dll","sys")
  | extend UnsignedOrBad = SignatureStatus in ("Unsigned","Invalid","Unknown") or isnull(Signer)
  | where UnsignedOrBad == true
  | project LoadTime=Timestamp,DeviceId,DeviceName,ProcessName,ProcessId,
            ImageFileName,FileExt,ImageSHA256=SHA256,Signer,SignatureStatus;

// 3. Registry-based execution/persistence
let reg_persistence =
  DeviceRegistryEvents
  | where Timestamp >= ago(lookback)
  | where ActionType in ("RegistryValueSet","RegistryValueAdded")
  | where RegistryValueData has_any (registry_keywords)
  | project RegTime=Timestamp,DeviceId,DeviceName,RegistryKey,RegistryValueData,
            RegInitiatingProcessFileName=InitiatingProcessFileName,
            RegInitiatingProcessCommandLine=InitiatingProcessCommandLine;

// 4. Network downloads of executable components
let net_downloads =
  DeviceNetworkEvents
  | where Timestamp >= ago(lookback)
  | where isnotempty(RemoteUrl)
  | where RemoteUrl has_any (".dll",".sys",".exe",".bin",".dat")
  | project DownloadTime=Timestamp,DeviceId,DeviceName,RemoteUrl,RemoteIP,RemotePort,
            NetInitiatingProcessFileName=InitiatingProcessFileName,
            NetInitiatingProcessCommandLine=InitiatingProcessCommandLine;

// 5. Correlation of events
file_drops
| join kind=leftouter image_loads on DeviceId,DeviceName
| join kind=leftouter net_downloads on DeviceId,DeviceName
| join kind=leftouter reg_persistence on DeviceId,DeviceName
| extend LoadDelayMin = iif(isnotempty(LoadTime),
                            datetime_diff("minute",LoadTime,DropTime), real(null))

// Flags
| extend SuspiciousDLLFast = iff(IsDLL == true and isnotempty(LoadTime)
                                 and LoadDelayMin between (0 .. 5), 1, 0)
| extend ParentHighValue = iff(ProcessName in (high_value_processes), 1, 0)
| extend LoaderIsLOLBIN = iff(InitiatingProcessFileName in (lolbin_loaders), 1, 0)
| extend DormantDriver = iff(IsDriver == true and 
                             DropTime <= now() - dormant_window and 
                             isnull(LoadTime), 1, 0)
| extend DormantDLL = iff(IsDLL == true and
                          DropTime <= now() - dormant_window and
                          isnull(LoadTime), 1, 0)

// Confidence scoring — TI removed
| extend ConfidenceScore =
    iif(DroppedInWritable == 1, 2, 0) +
    iif(isnotempty(RegistryKey), 2, 0) +
    iif(SuspiciousDLLFast == 1, 2, 0) +
    iif(DormantDriver == 1, 3, 0) +
    iif(ParentHighValue == 1, 2, 0) +
    iif(LoaderIsLOLBIN == 1, 1, 0) +
    iif(DormantDLL == 1, 3, 0)

// Reason
| extend Reason =
  case(
    DormantDriver == 1, "Dormant unsigned driver in writable path (BYOVD-style)",
    DormantDLL == 1, "Dormant DLL in writable path (SolarWinds-style)",
    SuspiciousDLLFast == 1, "Fast DLL load within 5 minutes of drop (3CX-style)",
    isnotempty(RegistryKey), "Registry persistence referencing executable",
    isnotempty(RemoteUrl), "Executable component downloaded from remote URL",
    "Behavioural anomaly"
  )

| where ConfidenceScore >= confidence_threshold

| project DropTime,LoadTime,DownloadTime,RegTime,DeviceName,FileName,SHA256,
          FolderPath,ImageFileName,ProcessName,RemoteUrl,RemoteIP,RegistryKey,
          RegistryValueData,SuspiciousDLLFast,DormantDriver,DormantDLL,
          ConfidenceScore,Reason
| order by DropTime desc
~~~

### ➤ [MISP/TI Integrated Version Of MDE Supply-Chain / Sideloading / Driver-Abuse KQL Rule](https://github.com/azdabat/Threat-Hunting-Rules/blob/main/SupplyChain-Detection/MDE_SupplyChain_Sideloading_DriverAbuse.kql)


This mapping is **behavioural**, not signature-based, making it resilient to polymorphism.

