# Case Study: Behavioural Detection of Polymorphic Loaders & Supply-Chain Sideloading  
### Using a Multi-Stage Sideloading & Driver-Abuse Detection Hunt (Ala Dabat)

This note describes a **behaviour-first detection approach** aimed at catching early stages of polymorphic malware and supply-chain compromise, using **Microsoft Defender for Endpoint Advanced Hunting**.

---

## 1. Why This Hunt Matters for Polymorphic & Supply-Chain Attacks

Polymorphic and supply-chain threats rarely reuse:

- Stable hashes  
- Fixed filenames or paths  
- Predictable infrastructure  

So relying mainly on hash or static IoCs gives very limited coverage, especially for:

- Supply-chain abuse (SolarWinds, 3CX, F5-style scenarios)  
- Polymorphic loaders (Latrodectus, Pikabot, Rhadamanthys, etc.)  
- BYOVD driver abuse  
- Delayed / staged DLL deployments  

This hunt ignores static artefacts as the primary signal and instead models **how** the intrusion behaves:

1. Component dropped into a user-writable / unusual path  
2. Unsigned / badly signed DLL or SYS  
3. Loaded by a high-value process (3CX, Outlook, Teams, svchost, etc.)  
4. Loaded very soon after being dropped (0–5 minutes)  
5. Loaded by a LOLBIN (rundll32, regsvr32, mshta, PowerShell)  
6. Dropped and left dormant for days (SolarWinds-style)  
7. Downloaded from a remote URL during the same timeframe  
8. Referenced from registry keys used for execution or persistence  

These are **behavioural invariants** seen repeatedly in modern access broker and supply-chain style activity.

---

## 2. Polymorphic Kill-Chain Coverage

| Kill Chain Stage    | Behaviour Detected                           | Covered | Strength      |
|---------------------|----------------------------------------------|---------|---------------|
| Initial foothold    | DLL / EXE / SYS in Temp / AppData            | ✔       | Medium        |
| Loader deployment   | Fast DLL load (< 5 min from drop)           | ✔       | Strong        |
| Memory prep         | Unsigned / unknown DLL / SYS loads          | ✔       | Strong        |
| Dormancy            | DLL / SYS dropped and never loaded (> 7 d)  | ✔       | Very strong   |
| BYOVD staging       | SYS driver dropped under writable paths      | ✔       | Strong        |
| C2 staging          | Executable / DLL / SYS pulled from RemoteUrl | ✔       | Medium        |
| Persistence         | Registry values referencing binaries         | ✔       | Strong        |
| Sideloading         | High-value process loads unsigned DLL        | ✔       | Very strong   |

---

## 3. Why This Helps Against Polymorphic Malware

Polymorphic families mutate:

- File structure and offsets  
- Packing stubs and sections  
- Per-host compilation and encryption  
- Execution timing (sleep / delay)  
- Loader behaviour wrapped in LOLBIN chains  

What they can’t fully hide is **how they are staged and loaded**:

- **Fast follow-up loads** (drop → load within minutes)  
- **Unsigned or questionable modules** under sensitive processes  
- **Writable-path staging** of DLLs / drivers  
- **Dormant binaries** that never execute but sit in key locations  
- **Registry references** to these components  
- **Remote download patterns** for DLL / SYS / EXE  

This hunt is built around those behavioural patterns.

**Examples:**

- **Latrodectus / similar loaders**  
  - Staged DLL under `%AppData%` or `%ProgramData%`  
  - Loaded by LOLBIN with short delay  
  - Unsigned module  
  → Flagged by *fast DLL load* + *LOLBIN parent* + *writable path*.

- **SolarWinds / SUNBURST-style dormancy**  
  - Backdoor DLL present for weeks before activation  
  → Flagged by *dormant DLL in writable or unusual path*.

- **NotPetya-style driver abuse**  
  - Modified drivers dropped in ProgramData / temp paths  
  → Flagged by *SYS in writable path* + *no load events*.

- **3CX-like sideloading**  
  - Sideloaded DLL under vendor application directory  
  - Loaded by high-value process  
  → Flagged by *high-value process parent* + *unsigned DLL* + *fast load*.

---

## 4. How This Fits with MDE, Sentinel, and Falcon

**Microsoft Defender for Endpoint (MDE)**  

Key tables:

- `DeviceFileEvents` – file drops and changes  
- `DeviceImageLoadEvents` – DLL / SYS loads, signer / signature status  
- `DeviceRegistryEvents` – execution / persistence keys  
- `DeviceNetworkEvents` – downloads and C2 patterns  

This hunt uses these to tie together **drop → load → registry → network** for the same host.

**Microsoft Sentinel**  

Sentinel can extend the picture with:

- Sysmon (if ingested)  
- Firewall / proxy logs  
- Cloud and identity logs (SigninLogs, AzureActivity)  

The idea is: use this MDE hunt as the **endpoint anchor** and then pivot in Sentinel for identity and cloud-side context.

**CrowdStrike Falcon**  

Falcon is strong at:

- Memory injection / hollowing  
- Cross-process manipulation  
- Thread creation into other processes  

The MDE hunt gives you **delivery / sideload / driver staging**; Falcon can confirm **in-memory behaviour**. Together you get a full-chain view.

---

## 5. Analyst Workflow When This Hunt Hits

1. **Validate the binary**  
   - Is the DLL / SYS / EXE part of a known installer or update?  
   - Is the publisher / signer expected for this host?  
   - If not clear or unknown → treat as suspicious.

2. **Check the process that loaded or dropped it**  
   - Parents like `rundll32.exe`, `regsvr32.exe`, `mshta.exe`, `powershell.exe` are higher risk.  
   - Business apps (3CX, Outlook, Teams) loading unsigned DLLs are also suspicious.

3. **Look for memory tampering**  
   - Follow up with hunts for `CreateRemoteThread`, `MemoryWrite`, etc. in `DeviceEvents` (if available) or Falcon telemetry.

4. **Check identity / sign-in side**  
   - For the affected user or host, pull sign-ins around the drop/load window (`SigninLogs` in Sentinel).  
   - Look for anomalous authentication, legacy protocols, impossible travel.

5. **Look for cloud metadata / token access**  
   - Check for metadata service access (e.g. `169.254.169.254`) or unusual cloud endpoints from the same host.

6. **Check potential lateral movement**  
   - On the same host, look for tools such as `psexec.exe`, `wmic.exe`, `sc.exe`, `powershell.exe` in `DeviceNetworkEvents` or `DeviceProcessEvents`.

7. **Scope the incident**  
   - Run the hunt across all devices to see how many hosts show similar patterns.  
   - Build a timeline: first occurrence, latest occurrence, which machines, which users.

---

## 6. MITRE ATT&CK Mapping (High Level)

| Technique   | Description                          | Behaviour in This Hunt                          |
|------------|--------------------------------------|-------------------------------------------------|
| T1574.001  | DLL sideloading                      | Unsigned DLL loaded by trusted / high-value app |
| T1543.003  | Driver / service creation / misuse   | SYS drivers staged under writable paths         |
| T1547.001  | Run key / registry-based persistence | Registry values referencing binaries or LOLBINs |
| T1105      | Ingress tool transfer                | DLL / SYS / EXE downloaded via `RemoteUrl`      |
| T1195      | Supply-chain compromise              | Trusted app loading an unexpected DLL / driver  |

---

## 7. KQL Hunt – Sideloading / Driver Abuse (Behaviour-First, TI-Free)

```kusto
// Sideloading / Driver Abuse Behavioural Hunt (MDE Advanced Hunting)
// Focus: DLL / SYS staged in writable paths, unsigned loads, fast load after drop, dormancy, registry ties, remote downloads
// Author: Ala Dabat

let lookback = 14d;
let dormant_window = 7d;
let confidence_threshold = 3;

// Common user-writable or suspicious directories
let suspicious_folders = dynamic([
  @"C:\ProgramData\",
  @"C:\Users\",
  @"C:\Temp\",
  @"C:\Windows\Tasks\",
  @"C:\Windows\Temp\"
]);

// Processes where unsigned DLLs are more worrying
let high_value_processes = dynamic([
  "3CXDesktopApp.exe",
  "SolarWinds.BusinessLayerHost.exe",
  "OUTLOOK.EXE",
  "Teams.exe",
  "explorer.exe",
  "svchost.exe",
  "services.exe",
  "winlogon.exe",
  "lsass.exe"
]);

// LOLBINs commonly used as loaders
let lolbin_loaders = dynamic([
  "rundll32.exe",
  "regsvr32.exe",
  "mshta.exe",
  "powershell.exe",
  "wscript.exe",
  "cscript.exe",
  "cmd.exe"
]);

// Registry value data patterns that typically reference executable content
let registry_keywords = dynamic([
  ".dll",".exe",".ps1",".bat",".vbs",".cmd",".js",
  "rundll32.exe","mshta.exe","powershell.exe","cmd.exe"
]);

// 1) File drops in suspicious locations (DLL / SYS / EXE)
let file_drops =
DeviceFileEvents
| where Timestamp >= ago(lookback)
| where FolderPath has_any (suspicious_folders)
| extend FileExt = tolower(split(FileName, ".", -1)[-1])
| where FileExt in ("dll","sys","exe")
| project
    DeviceId,
    DeviceName,
    DropTime = Timestamp,
    DroppedFileName = FileName,
    DroppedFolderPath = FolderPath,
    DroppedFileExt = FileExt,
    DroppedSHA256 = SHA256,
    DroppingProcessName = InitiatingProcessFileName,
    DroppingProcessCommandLine = InitiatingProcessCommandLine,
    DroppedInWritable = 1;

// 2) Unsigned or questionable DLL / SYS image loads
let image_loads =
DeviceImageLoadEvents
| where Timestamp >= ago(lookback)
| extend LoadedFileExt = tolower(split(FileName, ".", -1)[-1])
| where LoadedFileExt in ("dll","sys")
| extend UnsignedOrSuspicious =
    SignatureStatus in ("Unsigned","Invalid","Unknown") or isempty(Signer)
| where UnsignedOrSuspicious
| project
    DeviceId,
    DeviceName,
    LoadTime = Timestamp,
    LoaderProcessName = InitiatingProcessFileName,
    LoaderProcessCommandLine = InitiatingProcessCommandLine,
    LoadedFileName = FileName,
    LoadedFolderPath = FolderPath,
    LoadedFileExt,
    LoadedSHA256 = SHA256,
    Signer,
    SignatureStatus;

// 3) Registry events where values reference binaries / LOLBINs
let reg_persistence =
DeviceRegistryEvents
| where Timestamp >= ago(lookback)
| where ActionType in ("RegistryValueSet","RegistryValueAdded")
| where RegistryValueData has_any (registry_keywords)
| project
    DeviceId,
    DeviceName,
    RegTime = Timestamp,
    RegistryKey,
    RegistryValueData,
    RegistryProcessName = InitiatingProcessFileName,
    RegistryProcessCommandLine = InitiatingProcessCommandLine;

// 4) Network events that look like executable / library downloads
let net_downloads =
DeviceNetworkEvents
| where Timestamp >= ago(lookback)
| where isnotempty(RemoteUrl)
| where RemoteUrl has_any (".dll",".sys",".exe",".bin",".dat")
| project
    DeviceId,
    DeviceName,
    DownloadTime = Timestamp,
    RemoteUrl,
    RemoteIP,
    RemotePort,
    DownloadingProcessName = InitiatingProcessFileName,
    DownloadingProcessCommandLine = InitiatingProcessCommandLine;

// 5) Join the views together on host
file_drops
| join kind=leftouter image_loads on DeviceId, DeviceName
| join kind=leftouter net_downloads on DeviceId, DeviceName
| join kind=leftouter reg_persistence on DeviceId, DeviceName

// 6) Derived fields and flags
| extend LoadDelayMin =
    iff(isnotempty(LoadTime),
        datetime_diff("minute", LoadTime, DropTime),
        real(null))

// Fast DLL load shortly after drop (3CX-style patterns)
| extend SuspiciousDLLFast =
    iff(LoadedFileExt == "dll"
        and isnotempty(LoadTime)
        and LoadDelayMin between (0 .. 5), 1, 0)

// DLL or SYS dropped but never loaded for a long period (dormant component)
| extend DormantDLL =
    iff(DroppedFileExt == "dll"
        and DropTime <= now() - dormant_window
        and isnull(LoadTime), 1, 0)
| extend DormantDriver =
    iff(DroppedFileExt == "sys"
        and DropTime <= now() - dormant_window
        and isnull(LoadTime), 1, 0)

// High-value or LOLBIN parent processes for the load
| extend ParentHighValue =
    iff(LoaderProcessName in (high_value_processes), 1, 0)
| extend LoaderIsLOLBIN =
    iff(LoaderProcessName in (lolbin_loaders), 1, 0)

// 7) Simple confidence score (behaviour-based)
| extend ConfidenceScore =
      iif(DroppedInWritable == 1, 2, 0)
    + iif(isnotempty(RegistryKey), 2, 0)
    + iif(SuspiciousDLLFast == 1, 2, 0)
    + iif(DormantDriver == 1, 3, 0)
    + iif(DormantDLL == 1, 3, 0)
    + iif(ParentHighValue == 1, 2, 0)
    + iif(LoaderIsLOLBIN == 1, 1, 0)

// 8) Human-readable reason
| extend Reason =
  case(
    DormantDriver == 1, "Dormant unsigned or unknown driver in writable path (BYOVD-style staging)",
    DormantDLL == 1, "Dormant DLL in writable path or unusual folder (supply-chain / backdoor staging)",
    SuspiciousDLLFast == 1, "Unsigned DLL loaded within 5 minutes of drop (loader behaviour)",
    isnotempty(RegistryKey), "Registry value referencing executable or LOLBIN (possible persistence / execution)",
    isnotempty(RemoteUrl), "Executable or library component downloaded from remote URL on same host",
    "Behavioural anomaly involving staged DLL/SYS/EXE components"
  )

// 9) Only show higher-interest events
| where ConfidenceScore >= confidence_threshold

// 10) Output for triage
| project
    DeviceName,
    DropTime,
    LoadTime,
    DownloadTime,
    RegTime,
    DroppedFileName,
    DroppedFolderPath,
    DroppedFileExt,
    DroppedSHA256,
    LoadedFileName,
    LoadedFolderPath,
    LoadedFileExt,
    LoadedSHA256,
    DroppingProcessName,
    LoaderProcessName,
    DownloadingProcessName,
    RemoteUrl,
    RemoteIP,
    RegistryKey,
    RegistryValueData,
    SuspiciousDLLFast,
    DormantDLL,
    DormantDriver,
    ParentHighValue,
    LoaderIsLOLBIN,
    ConfidenceScore,
    Reason
| order by DropTime desc
